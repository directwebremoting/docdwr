<!DOCTYPE html>
<html>
<head>
  <title>Writing JavaScript with DWR</title>
  <meta name='weight' content='-13'>
  <meta name='alias' content='/dwr/browser/intro'>
  <meta name='navTitle' content='Scripting DWR'>
  <link rel="stylesheet" type="text/css" href="../media/styles.css">
</head>
<body>

<h1>Writing JavaScript with DWR</h1>

<p>DWR generates Javascript code that is similar to the Java code remoted, using the &lt;create ... &gt; element, in your dwr.xml file.</p>

<p>The biggest challenge in creating a remote interface to match Java code across Ajax is the (usually) asynchronous nature of Ajax, compared to the synchronous nature of a normal Java call.</p>

<p>DWR solves this problem by introducing a callback function that is called when the data is returned from the server.</p>

<p>There are 2 recommended ways to make a call using DWR. Either by appending a callback function to the parameter list or by appending a call options object.</p>

<h2>Simple Callback Functions</h2>

<p>Suppose we have a Java method that looks like this:</p>

<pre>
public class Remote {
    public String getData(int index) { ... }
}
</pre>

<p>We can use this from Javascript as follows:</p>

<pre>
&lt;script type="text/javascript"
    src="<i>[WEBAPP]</i>/dwr/interface/Remote.js"&gt; &lt;/script&gt;
&lt;script type="text/javascript"
    src="<i>[WEBAPP]</i>/dwr/engine.js"&gt; &lt;/script&gt;
...

function handleGetData(str) {
  alert(str);
}

Remote.getData(42, handleGetData);
</pre>

<p>'42' is just the parameter to the <code>getData()</code> Java function - see above.</p>

<p>Alternatively you can use the all-in-one-line version:</p>

<pre>
Remote.getData(42, function(str) { alert(str); });
</pre>

<h2>Call Option Objects</h2>

<p>The alternative syntax is to make use of a call option object that specifies the callback function and (optionally) other options. The example above would become:</p>

<pre>
Remote.getData(42, {
  callback:function(str) { alert(str); }
});
</pre>

<p>This method has some advantages: Depending on your style it may be easier to read, but more importantly it allows you to specify extra call options.</p>

<h3>Timeouts and Handling Errors</h3>

<p>In addition to the callback function you can also specify a timeout and an errorHandler. For example:</p>

<pre>
Remote.getData(42, {
  callback:function(str) { alert(str); },
  timeout:5000,
  errorHandler:function(message) { alert("Oops: " + message); }
});
</pre>

<h2>Finding the callback method</h2>

<p>There are some instances when it might not be tricky to distinguish between the various callback placement options. (Remember that Javascript does not support overloaded functions). For example:</p>

<pre>
Remote.method({ timeout:3 }, { errorHandler:somefunc });
</pre>

<p>One of the 2 parameters is a bean parameter and the other is a call option object but we have no way of telling which. In a cross-browser world we have to assume that null == undefined. So currently, the rules are:</p>

<ul>

<li>If there is a function last then this is the callback function, there is no call option object and the other parameters are the Java args.</li>

<li>Otherwise, if the last param is an object with a callback member that is a function then this is the call option object and the other params are Java args.</li>

<li>Finally if the last param is null, then there is no callback function.</li>

<li>Otherwise, this is a badly formatted request - signal an error.</li>

</ul>

<h2><a name="JStoMatchJava"></a>Creating Javascript objects to match Java objects</h2>

<p>Suppose you have an exposed Java method like this:</p>

<pre>
public class Remote {
  public void setPerson(Person p) {
    this.person = p;
  }
}
</pre>

<p>And <code>Person</code> looks like this:</p>

<pre>
public Person {
  private String name;
  private int age;
  private Date[] appointments;
  // getters and setters ...
}
</pre>

<p>Then you can call this from Javascript like this:</p>

<pre>
var p = {
  name:"Fred Bloggs",
  age:42,
  appointments:[ new Date(), new Date("1 Jan 2008") ]
};
Remote.setPerson(p);
</pre>

<p>Any fields missing from the Javascript representation will be left unset in the Java version.</p>

<p>Since the setter returned 'void' we did not need to use a callback and could just leave it out. If you want to be notified of the completion of a server-side method that returns void then you can include a callback method. Obviously DWR will not pass any data to it.</p>

</body>
</html>
